advent_of_code::solution!(4);
use sscanf::sscanf;
use std::{
    cmp::min,
    collections::{HashMap, HashSet},
};

#[derive(Debug)]
struct Card {
    id: usize,
    winners: HashSet<u32>,
    nums: HashSet<u32>,
}

pub fn part_one(input: &str) -> Option<u32> {
    Some(
        input
            .lines()
            .map(|l| count_winners(&parse_line(l)))
            .filter_map(
                |n| if n == 0 { None } else { Some(2_u32.pow((n - 1).try_into().unwrap())) },
            )
            .sum(),
    )
}
fn parse_line(line: &str) -> Card {
    let (id, winners, nums) = sscanf!(line, "Card {usize}: {String} | {String}").unwrap();

    let winners: HashSet<u32> = winners.split_whitespace().map(|n| n.parse().unwrap()).collect();
    let nums: HashSet<u32> = nums.split_whitespace().map(|n| n.parse().unwrap()).collect();
    Card { id, winners, nums }
}

fn count_winners(card: &Card) -> usize {
    card.winners.intersection(&card.nums).count()
}

pub fn part_two(input: &str) -> Option<usize> {
    let cards = input.lines().map(parse_line).collect::<Vec<Card>>();
    let mut counts = vec![1; cards.len()];

    for (i, card) in cards.iter().enumerate() {
        let wins = count_winners(card);
        for j in i + 1..min(i + 1 + wins, cards.len()) {
            counts[j] += counts[i]
        }
    }

    Some(counts.into_iter().sum())
}

// A DFS solution which is more general if the traversal isn't causal.
// pub fn part_two(input: &str) -> Option<usize> {
//     let cards: HashMap<usize, Card> = input
//         .lines()
//         .map(|l| {
//             let card = parse_line(l);
//             (card.id, card)
//         })
//         .collect();
//     let max_card_id = cards.len();
//     let mut memo_counts: HashMap<usize, usize> = HashMap::new();
//     let mut intersection_sizes: HashMap<usize, usize> = HashMap::new();
//     Some(
//         // The number of cards generated by each card.
//         (1..=max_card_id)
//             .map(|i| {
//                 count_generated(
//                     &cards[&i],
//                     &cards,
//                     max_card_id,
//                     &mut intersection_sizes,
//                     &mut memo_counts,
//                 )
//             })
//             .sum::<usize>(),
//     )
// }

// fn count_generated(
//     card: &Card,
//     cards: &HashMap<usize, Card>,
//     max_card_id: usize,
//     intersection_sizes: &mut HashMap<usize, usize>,
//     memo_counts: &mut HashMap<usize, usize>,
// ) -> usize {
//     dbg!(card.id);

//     // Return memoized value if found.
//     if let Some(&count) = memo_counts.get(&card.id) {
//         println!("memo (id: {}, total: {})", card.id, count);
//         return count;
//     }

//     let win_count = *intersection_sizes
//         .entry(card.id)
//         .or_insert_with(|| card.nums.intersection(&card.winners).count());

//     let lo = card.id + 1;
//     let hi = min(lo + win_count, max_card_id);

//     dbg!(lo, hi, lo..hi);

//     for i in lo..hi {
//         dbg!(i);
//     }
//     let generated: usize = (lo..hi)
//         .map(|id| count_generated(&cards[&id], cards, max_card_id, intersection_sizes, memo_counts))
//         .sum();

//     let total = 1 + generated;
//     // Save the count.
//     memo_counts.insert(card.id, total);

//     println!("Computed (id: {}, total: {})", card.id, total);

//     total
// }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part_one() {
        let result = part_one(&advent_of_code::template::read_file("examples", DAY));
        assert_eq!(result, Some(13));
    }

    #[test]
    fn test_part_two() {
        let result = part_two(&advent_of_code::template::read_file("examples", DAY));
        assert_eq!(result, Some(30));
    }
}
